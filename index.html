<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ—‹è½¬åœ£è¯æ ‘ - æ‰‹æœºäº’åŠ¨ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
            user-select: none;
            /* é˜²æ­¢æ‰‹æœºåŒå‡»ç¼©æ”¾ */
            touch-action: none; 
        }

        /* --- ä¿®æ”¹ç‚¹ 1: è°ƒæ•´æŒ‰é’®ä½ç½®åˆ°å³ä¾§ä¸­é—´å‚ç›´æ’åˆ— --- */
        #ui-container {
            position: absolute;
            top: 50%; /* å‚ç›´å±…ä¸­ */
            right: 20px;
            transform: translateY(-50%); /* ä¿®æ­£è‡ªèº«çš„åç§» */
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            gap: 15px; /* å¢åŠ é—´è·æ–¹ä¾¿æ‰‹æŒ‡ç‚¹å‡» */
            z-index: 100;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 15px; /* ç¨å¾®åŠ å¤§å†…è¾¹è· */
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            pointer-events: none;
            transition: opacity 1s;
        }

        #tips {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        /* è®¸æ„¿å¼¹çª— */
        #wish-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffcc;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
            min-width: 250px;
        }
        #wish-input {
            background: transparent;
            border: none;
            border-bottom: 2px solid white;
            color: white;
            padding: 10px;
            font-size: 18px;
            outline: none;
            width: 80%;
            text-align: center;
            margin-top: 10px;
        }
        #wish-btn {
            margin-top: 20px;
            background: #00ffcc;
            color: black;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="tips">âœ¨ æ‹–æ‹½æ—‹è½¬ | â­ ç‚¹å‡»æ˜Ÿæ˜Ÿè®¸æ„¿</div>
    <div id="loading">æ­£åœ¨ç”Ÿæˆé­”æ³•ç²’å­...</div>

    <!-- æŒ‰é’®ç»„ï¼šå·²æ”¹ä¸ºå³ä¾§å‚ç›´æ’åˆ— -->
    <div id="ui-container">
        <button class="btn" onclick="changeTheme('classic')">ğŸ„ ç»å…¸çº¢ç»¿</button>
        <button class="btn" onclick="changeTheme('frozen')">â„ï¸ å†°é›ªå¥‡ç¼˜</button>
        <button class="btn" onclick="changeTheme('cyber')">ğŸ‘¾ èµ›åšæœ‹å…‹</button>
    </div>

    <!-- è®¸æ„¿æ¡† -->
    <div id="wish-modal">
        <div style="color:white; font-size: 18px;">âœ¨ è¾“å…¥æ–°å¹´æ„¿æœ› âœ¨</div>
        <input type="text" id="wish-input" placeholder="ä¾‹å¦‚ï¼šå¹³å®‰å–œä¹" maxlength="12">
        <br>
        <button id="wish-btn" onclick="submitWish()">å‘é€æ˜Ÿç©º</button>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- 2. åŠ¨æ€ç”Ÿæˆçº¹ç† ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        const particleTexture = createParticleTexture();

        // --- 3. åœ£è¯æ ‘é€»è¾‘ ---
        const themes = {
            classic: { leaf: 0x0f5c0f, light1: 0xff0000, light2: 0xffd700, ribbon: 0xffd700, bg: '#1a1a2e' },
            frozen:  { leaf: 0x88ccff, light1: 0xffffff, light2: 0x00ffff, ribbon: 0xffffff, bg: '#091a2b' },
            cyber:   { leaf: 0xff00ff, light1: 0x00ffcc, light2: 0xffff00, ribbon: 0x00ffff, bg: '#000000' }
        };
        let currentTheme = themes.classic;

        let treeSystem, ornamentSystem, ribbonSystem, starMesh, snowSystem;
        let wishes = [];

        function createTree() {
            // A. æ ‘å¶
            const leafGeometry = new THREE.BufferGeometry();
            const leafCount = 3000;
            const positions = [];
            const colors = [];
            const leafColorObj = new THREE.Color(currentTheme.leaf);

            for (let i = 0; i < leafCount; i++) {
                const percent = i / leafCount;
                const angle = i * 0.15;
                const height = 20;
                const radius = (percent) * 8;
                const y = (1 - percent) * height;
                const randomR = Math.random() * 0.5;
                const x = Math.cos(angle) * (radius + randomR);
                const z = Math.sin(angle) * (radius + randomR);

                positions.push(x, y - 10, z);
                const c = leafColorObj.clone().multiplyScalar(0.5 + Math.random() * 0.5);
                colors.push(c.r, c.g, c.b);
            }
            leafGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            leafGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const leafMaterial = new THREE.PointsMaterial({
                size: 0.6, vertexColors: true, map: particleTexture,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            treeSystem = new THREE.Points(leafGeometry, leafMaterial);
            scene.add(treeSystem);

            // B. ç¯çƒ
            const ornamentGeometry = new THREE.BufferGeometry();
            const ornamentCount = 200;
            const oPositions = [];
            const oColors = [];
            const c1 = new THREE.Color(currentTheme.light1);
            const c2 = new THREE.Color(currentTheme.light2);
            for(let i=0; i<ornamentCount; i++) {
                const percent = Math.random();
                const y = (1 - percent) * 20 - 10;
                const radius = percent * 8 + 0.2;
                const angle = Math.random() * Math.PI * 2;
                oPositions.push(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                const c = Math.random() > 0.5 ? c1 : c2;
                oColors.push(c.r, c.g, c.b);
            }
            ornamentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(oPositions, 3));
            ornamentGeometry.setAttribute('color', new THREE.Float32BufferAttribute(oColors, 3));
            const ornamentMaterial = new THREE.PointsMaterial({
                size: 1.2, vertexColors: true, map: particleTexture,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            ornamentSystem = new THREE.Points(ornamentGeometry, ornamentMaterial);
            scene.add(ornamentSystem);

            // C. å½©å¸¦
            const ribbonGeometry = new THREE.BufferGeometry();
            const ribbonCount = 1200;
            const rPositions = [];
            const rColors = [];
            const ribbonColor = new THREE.Color(currentTheme.ribbon);
            for (let i = 0; i < ribbonCount; i++) {
                const percent = i / ribbonCount; 
                const loops = 5; 
                const angle = percent * Math.PI * 2 * loops; 
                const height = 20;
                const radius = (percent) * 8.5 + (Math.random() - 0.5) * 0.4; 
                const y = (1 - percent) * height - 10;
                rPositions.push(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                const c = ribbonColor.clone().multiplyScalar(0.8 + Math.random() * 0.4);
                rColors.push(c.r, c.g, c.b);
            }
            ribbonGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rPositions, 3));
            ribbonGeometry.setAttribute('color', new THREE.Float32BufferAttribute(rColors, 3));
            const ribbonMaterial = new THREE.PointsMaterial({
                size: 0.5, vertexColors: true, map: particleTexture,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
            });
            ribbonSystem = new THREE.Points(ribbonGeometry, ribbonMaterial);
            scene.add(ribbonSystem);
        }

        // --- 4. æ˜Ÿæ˜Ÿ ---
        function createStar() {
            const geometry = new THREE.OctahedronGeometry(1.5, 0);
            const material = new THREE.MeshBasicMaterial({ color: 0xffdd00, wireframe: true });
            starMesh = new THREE.Mesh(geometry, material);
            starMesh.position.set(0, 11, 0);
            const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.8, 0), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            starMesh.add(core);
            scene.add(starMesh);
        }

        // --- 5. é›ªèŠ± ---
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = [];
            const velocities = [];
            for(let i=0; i<count; i++) {
                positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50+10, (Math.random()-0.5)*50);
                velocities.push(0.05 + Math.random() * 0.1);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.userData = { velocities: velocities };
            const material = new THREE.PointsMaterial({
                size: 0.5, color: 0xffffff, map: particleTexture,
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
            });
            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        // --- 6. è®¸æ„¿æ–‡å­— ---
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128; // åŠ å®½ç”»å¸ƒé˜²æ­¢æ–‡å­—æˆªæ–­
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0,0,512,128);
            ctx.font = "Bold 50px Arial";
            ctx.fillStyle = "#ffdd00";
            ctx.textAlign = "center";
            ctx.shadowColor = "rgba(255,255,0,1)";
            ctx.shadowBlur = 10;
            ctx.fillText(text, 256, 80);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(8, 2, 1);
            return sprite;
        }

        // åˆå§‹åŒ–
        createTree();
        createStar();
        createSnow();
        document.getElementById('loading').style.opacity = 0;

        // --- 7. äº¤äº’é€»è¾‘ (æ ¸å¿ƒä¿®æ”¹ï¼šæ”¯æŒæ‰‹æœºè§¦æ‘¸) ---
        
        window.changeTheme = function(themeName) {
            currentTheme = themes[themeName];
            scene.remove(treeSystem);
            scene.remove(ornamentSystem);
            scene.remove(ribbonSystem);
            createTree();
            if(themeName === 'classic') document.body.style.background = `radial-gradient(circle at center, #1a1a2e 0%, #000000 100%)`;
            if(themeName === 'frozen') document.body.style.background = `radial-gradient(circle at center, #091a2b 0%, #000000 100%)`;
            if(themeName === 'cyber') document.body.style.background = `radial-gradient(circle at center, #220022 0%, #000000 100%)`;
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ç»Ÿä¸€å¤„ç†å°„çº¿æ£€æµ‹
        function handleInteraction(x, y) {
            // å½’ä¸€åŒ–è®¾å¤‡åæ ‡ (-1 åˆ° +1)
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // recursive: true ç”¨äºæ£€æµ‹æ˜Ÿæ˜Ÿå†…éƒ¨çš„å­å¯¹è±¡
            const intersects = raycaster.intersectObject(starMesh, true);

            if (intersects.length > 0) {
                document.getElementById('wish-modal').style.display = 'block';
                controls.autoRotate = false;
                
                // èšç„¦è¾“å…¥æ¡†ï¼Œä¼˜åŒ–æ‰‹æœºä½“éªŒ
                setTimeout(() => {
                    document.getElementById('wish-input').focus();
                }, 100);
            }
        }

        // PC é¼ æ ‡ç‚¹å‡»
        window.addEventListener('click', (event) => {
            // å¿½ç•¥ç”±äºæ‹–æ‹½ç»“æŸè§¦å‘çš„ç‚¹å‡» (å¯é€‰ï¼Œç®€å•åœºæ™¯ä¸å¤„ç†ä¹Ÿè¡Œ)
            handleInteraction(event.clientX, event.clientY);
        });

        // ã€ä¿®æ”¹ç‚¹ 2ã€‘æ‰‹æœºè§¦æ‘¸æ”¯æŒ
        window.addEventListener('touchstart', (event) => {
            if(event.touches.length > 0) {
                // è·å–ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹
                const t = event.touches[0];
                handleInteraction(t.clientX, t.clientY);
            }
        }, { passive: false }); // passive: false å…è®¸åœ¨éœ€è¦æ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º

        window.submitWish = function() {
            const input = document.getElementById('wish-input');
            const text = input.value.trim();
            if(text) {
                const sprite = createTextSprite(text);
                const angle = Math.random() * Math.PI * 2;
                const r = 10 + Math.random() * 5;
                sprite.position.set(Math.cos(angle)*r, Math.random()*10 - 5, Math.sin(angle)*r);
                sprite.userData = { 
                    angle: angle, 
                    radius: r, 
                    speed: 0.01 + Math.random() * 0.02,
                    yBase: sprite.position.y
                };
                scene.add(sprite);
                wishes.push(sprite);
                input.value = '';
            }
            document.getElementById('wish-modal').style.display = 'none';
            controls.autoRotate = true;
        };

        // --- 8. åŠ¨ç”» ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            if(treeSystem) {
                ornamentSystem.rotation.y = -time * 0.1; 
                ribbonSystem.rotation.y = -time * 0.15;
            }
            if(starMesh) {
                starMesh.rotation.y += 0.02;
                starMesh.rotation.z = Math.sin(time) * 0.1;
                const scale = 1 + Math.sin(time * 3) * 0.2;
                starMesh.scale.set(scale, scale, scale);
            }
            if(snowSystem) {
                const p = snowSystem.geometry.attributes.position.array;
                const v = snowSystem.geometry.userData.velocities;
                for(let i=0; i < p.length; i+=3) {
                    p[i+1] -= v[i/3];
                    if(p[i+1] < -20) {
                        p[i+1] = 20; p[i] = (Math.random()-0.5)*50; p[i+2] = (Math.random()-0.5)*50;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y = time * 0.05;
            }
            wishes.forEach(sprite => {
                const d = sprite.userData;
                d.angle += d.speed;
                sprite.position.x = Math.cos(d.angle) * d.radius;
                sprite.position.z = Math.sin(d.angle) * d.radius;
                sprite.position.y = d.yBase + Math.sin(time * 1 + d.angle) * 1;
            });
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>